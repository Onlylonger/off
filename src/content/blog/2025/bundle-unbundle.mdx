---
title: 现代库构建新范式：Unbundled 模式下的 UI 库开发指南

description: 在 JavaScript 生态中，我们正经历一场构建范式的革命。传统的大型打包方案（如 Webpack）正在被更轻量、更高效的模块化构建（Unbundled Build）所取代。这种转变对于 UI 库开发尤为重要——开发者需要构建出既保持模块独立性，又能被现代工具链高效使用的组件库。

pubDate: "3.15"
---

# {frontmatter.title}

描述：{frontmatter.description}

> Initial version generated by DeepSeek.

本文将深入探讨如何利用现代工具实现高质量的 Unbundled 构建，让您的 UI 库在速度、兼容性和开发者体验上达到完美平衡。

## 一、Unbundled 构建的核心价值

为什么 UI 库需要 Unbundled 构建？

1. 按需加载优势：消费者项目只需导入实际使用的组件

2. 优化 Tree Shaking：打包工具能更精确地消除未使用代码

3. 加速构建过程：避免全量打包带来的性能损耗

4. 简化调试体验：保持源码结构，便于问题定位

5. 跨环境兼容：同时支持现代浏览器和传统构建流程

> "Unbundled 构建不是趋势，而是现代库开发的基本要求。" - Rich Harris（Svelte 作者）

## 二、核心工具与技术实现

### 1. ESBuild：极速转换的利器

ESBuild 凭借其 Go 语言优势，提供无与伦比的编译速度：

```js
// ESBuild 单文件转换示例

import { transform } from "esbuild";

const tsxToEsm = async (code) => {
  const result = await transform(code, {
    loader: "tsx",

    format: "esm",

    jsx: "automatic",
  });

  return result.code;
};

// 使用示例

const componentCode = `

export function Button() {

return <button>Click</button>

}

`;

const esmCode = await tsxToEsm(componentCode);
```

优势：

- 比传统工具快 10-100 倍

- 支持 TS/JSX 等现代语法

- 极简 API 设计

局限：

- CSS 支持有限

- 插件生态相对薄弱

### 2. Rollup：成熟稳定的选择

Rollup 的 preserveModules 模式是库构建的金标准：

```js
// rollup.config.js

import postcss from "rollup-plugin-postcss";

export default {
  input: "src/index.js",

  output: {
    dir: "dist",

    format: "esm",

    preserveModules: true, // 关键配置
  },

  plugins: [
    postcss({
      modules: true, // CSS Modules 支持

      extract: true, // 独立 CSS 文件

      minimize: true, // 压缩输出
    }),
  ],
};
```

优势：

- 完善的模块化支持

- 强大的插件生态系统

- 精确控制输出结构

典型工作流：

1. 将每个组件编译为独立 ESM 文件

2. 提取 CSS 到单独文件

3. 保持原始目录结构

4. 生成类型声明文件

### 3. Rolldown：未来的高性能方案

作为 Rollup 的 Rust 实现，Rolldown 提供相同 API 但显著提升的性能：

```js
// rolldown.config.js (与 Rollup 配置兼容)

export default {
  input: "src/index.js",

  output: {
    dir: "dist",

    format: "esm",

    preserveModules: true,
  },

  plugins: [
    // 使用与 Rollup 相同的插件
  ],
};
```

优势：

- 编译速度提升 2-5 倍

- 兼容 Rollup 插件生态

- 内存占用更低

现状：2025 年仍处于 Beta 阶段，但已可用于生产环境

## 三、CSS 处理的艺术

在 Unbundled 构建中，CSS 处理需要特别关注：

### 推荐方案：PostCSS 插件生态

```js
// 通用 CSS 处理配置

import postcss from "rollup-plugin-postcss";

export default {
  plugins: [
    postcss({
      modules: {
        generateScopedName: "[name]__[local]___[hash:base64:5]",
      },

      extract: "dist/styles.css",

      plugins: [require("autoprefixer"), require("cssnano")],
    }),
  ],
};
```

支持的功能

1. CSS Modules：自动作用域隔离

2. 预处理支持：Sass/Less/Stylus

3. 自动前缀：跨浏览器兼容

4. 关键 CSS 提取：优化首屏加载

5. 压缩优化：减少文件体积

## 四、高级场景：Vite 的库模式

Vite 为库开发提供了开箱即用的优化方案：

```js
// vite.config.js

import { defineConfig } from "vite";

export default defineConfig({
  build: {
    lib: {
      entry: "src/index.js",

      name: "MyUI",

      formats: ["es"],
    },

    rollupOptions: {
      output: {
        preserveModules: true,

        preserveModulesRoot: "src",
      },
    },
  },

  css: {
    modules: {
      localsConvention: "camelCaseOnly",
    },
  },
});
```

优势特性：

- 内置 TS/JSX 支持

- 开发服务器即时反馈

- 智能依赖预构建

- 无缝对接 Rollup 生态

## 五、工具选型指南

### 决策矩阵

| 需求 | 推荐工具 | 理由 |

| ---------------------- | -------- | ---------------------------- |

| 纯 JS/TS 库，追求速度 | ESBuild | 极速转换，简单直接 |

| 含 CSS 的完整组件库 | Rollup | 成熟生态，完整 CSS 支持 |

| 大型库，未来导向 | Rolldown | 高性能，兼容现有生态 |

| 复杂构建，需要开发环境 | Vite | 一体化解决方案，开发体验优秀 |

性能对比

| 工具 | 编译速度 | 输出质量 | CSS 支持 | 生态成熟度 |

| -------- | ---------- | ---------- | ---------- | ---------- |

| ESBuild | [表情][表情][表情][表情][表情] | [表情][表情]☆☆☆ | [表情]☆☆☆☆ | 中等 |

| Rollup | [表情][表情][表情]☆☆ | [表情][表情][表情][表情][表情] | [表情][表情][表情][表情][表情] | 完善 |

| Rolldown | [表情][表情][表情][表情]☆ | [表情][表情][表情][表情][表情] | [表情][表情][表情][表情][表情] | 成长中 |

| Vite | [表情][表情][表情][表情]☆ | [表情][表情][表情][表情]☆ | [表情][表情][表情][表情]☆ | 完善 |

## 六、最佳实践与优化技巧

### 1. 结构设计原则

```text

my-ui-library/

├─ src/

│ ├─ components/

│ │ ├─ Button/

│ │ │ ├─ index.tsx // 组件入口

│ │ │ ├─ Button.tsx // 组件实现

│ │ │ └─ Button.module.css // 组件样式

│ ├─ index.ts // 库入口

├─ dist/

│ ├─ components/

│ │ ├─ Button/

│ │ │ ├─ index.js // 保留原始结构

│ │ │ └─ Button.module.css

```

### 2. 按需加载实现

消费者项目使用示例：

```js
// 只导入需要的组件

import { Button } from "my-ui-library/components/Button";

// 而不是

// import { Button } from 'my-ui-library'
```

### 3. 类型声明生成

使用 tsc 或 rollup-plugin-dts 生成类型文件：

```bash

tsc --emitDeclarationOnly --outDir dist/types

```

### 4. 版本控制策略

```text

package.json

{

"exports": {

".": {

"types": "./dist/types/index.d.ts",

"import": "./dist/index.js"

},

"./components/*": {

"types": "./dist/types/components/*/index.d.ts",

"import": "./dist/components/*/index.js"

}

}

}

```

## 七、未来展望

Unbundled 构建正在成为库开发的标准范式，未来趋势包括：

1. Rolldown 成熟：成为 Rollup 的高性能替代

2. ESM 原生普及：浏览器直接支持模块导入

3. 构建工具融合：开发和生产使用统一工具链

4. WASM 加速：跨语言构建性能进一步提升

## 结语：选择合适的工具

在 UI 库开发中，没有放之四海皆准的解决方案。选择工具时需考虑：

- 项目规模：小型库可选用 ESBuild，大型库推荐 Rollup/Rolldown

- 团队熟悉度：沿用熟悉工具可降低学习成本

- CSS 需求：复杂样式处理需要 Rollup 生态支持

- 未来兼容：选择有持续维护的工具

无论选择哪种方案，保持模块化的输出结构是现代化 UI 库的核心要求。通过本文介绍的工具和技术，您将能够构建出高性能、高兼容性的前端组件库，为整个生态系统提供可靠的基础设施。

### 示例项目参考：

[Rollup UI 库模板](https://github.com/rollup/rollup-starter-lib)

[Vite 库模式文档](https://vite.dev/guide/build.html#library-mode)

[Modern Library Starter Kit](https://github.com/andywer/modern-lib-starter)
