---
title: 轻量处理 React Component 数据请求

description: React组件中如何处理数据请求，特别是在非复杂项目中，不需要使用像React Query、SWR这样具有缓存、聚焦刷新等高级特性的库。个人倾向于自定义一个useRequest钩子，提供常用的data, error, loading状态以及手动触发函数run，并且支持手动触发（manual）。

pubDate: "7.15"
---

# {frontmatter.title}

描述：{frontmatter.description}

> Initial version generated by DeepSeek.

## 为什么选择自定义Hook而非复杂库？

在中等规模项目中引入如React Query或SWR这样的库，就像用火箭筒打蚊子——功能强大但过度复杂。它们带来的问题包括：

- 陡峭的学习曲线：团队成员需要掌握新概念

- 不必要的开销：项目中增加了大量用不到的代码

- 灵活性受限：固定的范式限制了特殊场景的实现

> "简单问题应该用简单方案解决——自定义Hook正是这把恰到好处的瑞士军刀"

## 设计 useRequest Hook

下面是我们的useRequest Hook实现，它提供了开发中最常用的功能：

```js
import { useState, useCallback, useEffect } from "react";

const useRequest = (requestFn, options = {}) => {
  // 解构配置项

  const { manual = false, initialData = null, onSuccess, onError } = options;

  // 状态管理

  const [data, setData] = useState(initialData);

  const [error, setError] = useState(null);

  const [loading, setLoading] = useState(!manual);

  // 请求执行函数

  const run = useCallback(
    async (...args) => {
      try {
        setLoading(true);

        setError(null);

        const result = await requestFn(...args);

        setData(result);

        if (onSuccess) onSuccess(result);

        return result;
      } catch (err) {
        setError(err);

        if (onError) onError(err);

        throw err;
      } finally {
        setLoading(false);
      }
    },

    [requestFn, onSuccess, onError],
  );

  // 自动执行（非手动模式）

  useEffect(() => {
    if (!manual) {
      run();
    }
  }, [manual, run]);

  // 返回状态和执行函数

  return {
    data,

    error,

    loading,

    run,
  };
};

export default useRequest;
```

## 在组件中的实际应用

### 基本使用场景

```jsx
import useRequest from "./hooks/useRequest";

const fetchUser = async (userId) => {
  const response = await fetch(`/api/users/${userId}`);

  if (!response.ok) throw new Error("用户获取失败");

  return response.json();
};

const UserProfile = ({ userId }) => {
  const {
    data: user,

    loading,

    error,
  } = useRequest(
    () => fetchUser(userId),

    { manual: false }, // 自动加载
  );

  if (loading) return <div className="spinner">加载中...</div>;

  if (error) return <div className="error">错误: {error.message}</div>;

  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />

      <h2>{user.name}</h2>

      <p>{user.bio}</p>
    </div>
  );
};
```

### 手动触发场景

```jsx
const SearchForm = () => {
  const [query, setQuery] = useState("");

  const { data, loading, error, run } = useRequest(
    (searchTerm) =>
      fetch(`/api/search?q=${searchTerm}`).then((res) => res.json()),

    { manual: true }, // 手动触发
  );

  const handleSubmit = (e) => {
    e.preventDefault();

    run(query); // 手动执行请求
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="输入搜索内容..."
        />

        <button type="submit" disabled={loading}>
          {loading ? "搜索中..." : "搜索"}
        </button>
      </form>

      {error && <p className="error">搜索失败: {error.message}</p>}

      {data && (
        <ul className="results">
          {data.results.map((item) => (
            <li key={item.id}>{item.title}</li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

## 高级功能扩展

### 添加刷新功能

```jsx
const useEnhancedRequest = (requestFn, options) => {
  const basicRequest = useRequest(requestFn, options);

  // 添加刷新功能

  const refresh = useCallback(() => {
    return basicRequest.run();
  }, [basicRequest]);

  return {
    ...basicRequest,

    refresh,
  };
};
```

### 添加取消功能

```jsx
const useCancelableRequest = (requestFn, options) => {
  const [cancelToken, setCancelToken] = useState(null);

  const enhancedRequest = useRequest(async (...args) => {
    // 取消之前的请求

    if (cancelToken) {
      cancelToken.cancel("新请求已发起");
    }

    // 创建新的取消令牌

    const newToken = { cancel: () => {} };

    setCancelToken(newToken);

    try {
      return await requestFn(...args, newToken);
    } finally {
      setCancelToken(null);
    }
  }, options);

  // 取消当前请求

  const cancel = useCallback(() => {
    if (cancelToken) {
      cancelToken.cancel("用户手动取消");

      setCancelToken(null);
    }
  }, [cancelToken]);

  return {
    ...enhancedRequest,

    cancel,
  };
};
```

## 最佳实践建议

1. 错误处理标准化：

```jsx
const { error } = useRequest(fetchData);

useEffect(() => {
  if (error) {
    // 统一错误处理逻辑

    showNotification(`错误: ${error.message}`);
  }
}, [error]);
```

2. 请求防抖：

```jsx
const searchRequest = useDebouncedRequest(
  searchAPI,

  300, // 300ms防抖
);
```

3. 依赖管理：

```jsx
// 当userId变化时重新获取数据

const { data } = useRequest(() => fetchUser(userId), {
  manual: false,

  dependencies: [userId],
});
```

4. 加载状态优化：

```jsx
const { loading } = useRequest(fetchData);

return <div>{loading ? <SkeletonLoader /> : <ActualContent />}</div>;
```

## 结语

在React开发中，数据请求处理不需要总是复杂化。通过自定义Hook，我们能够在保持代码简洁的同时，满足绝大多数应用场景的需求。
